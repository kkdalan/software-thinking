## 架構思維：在軟體世界中找回方向感


### 人類理解這個世界的眼光：直角坐標系

很久以前，人類在大地上四處奔走，左看看、右看看，但卻經常搞不清自己究竟走到哪了。想像一下在一片無邊無際的沙漠裡，你心裡明明想著往右走，卻稀里糊塗地走到前面去了。綠洲明明就在那，但我就是走不到那裏。這是在笛卡爾之前的世界中，人們經常面對的方位挑戰。

據說笛卡爾的直角坐標系是從看蚊子飛行得到靈感的。某天，笛卡爾正躺在床上，看著房間裡的一隻蚊子在空中亂飛。他開始思考這隻蚊子在三維空間中運動的路徑，並試圖找出一個簡單的方法來描述它的位置。突然，他想到可以用天花板和牆壁來劃分出一個坐標系，將蚊子的位置用數字來描述：水平位置用 X 軸，垂直位置用 Y 軸，這樣無論蚊子飛到哪個位置，都可以用這兩個值來精確定位。

這個想法就是直角坐標系的早期雛形，成為人類往後文明方展的重要工具。在軟體的世界中，面對客戶漫天紛飛的需求，你我是不是也常有一種不知所措的嘆息，迷失在軟體世界的「大沙漠」中。

### 軟體世界的「直角坐標系」：軟體架構

當我們從這個故事轉向現代軟體開發的領域時，你可能會發現這裡也存在類似的迷失困境。你拿到一個用戶需求，明明對方要求的是開發一個功能性需求，結果你卻不知怎的，硬是搞出了一堆非功能性的優化功能，搞得大家摸不著頭腦，連客戶都開始懷疑他自己是不是表達錯了。

笛卡爾的直角坐標系其實給了我們很大的啟發，在本質上，Ｘ軸與Y軸其實就是維度的思考角度，我們也可以在軟體的世界中發揮維度的思考，也就是軟體架構的議題探討。

在與客戶討論軟體需求時，常常會聽到他們這麼說：「我要一個簡單的用戶註冊功能就好，註冊的時候要填手機號碼，還要檢核格式喔！」、「用戶的個人資料必須加密，這很重要！」、「系統一定要能24小時不停運作！」。每次聽到這些需求，總讓人感覺好像不太難，但到真正實際開發時，卻發現需求環環相扣，有時候甚至千一髮動全身，心中有股「剪不斷，理還亂。」的情緒。其實這就是「功能性需求」與「非功能性需求」混雜的場景，如果我們戴上笛卡爾的眼鏡，就可以發現，「功能性需求」與「非功能性需求」正式軟體架構中的「X軸」與「Ｙ軸」，我們也就有了軟體架構的「直角座標系」。

有了直角座標系這個工具，開發團隊開始動工時，就比較不會再迷失在功能與性能之間的糾纏裡，而是可以有條不紊地對焦每個需求點，確保執行的優先序，也有助於開發上的分工，最終產出的軟體功能也能夠有節奏地滿足用戶的需求。至此，我們品嚐到了維度思考的一點甜頭，但是我們不會就此滿足，面段軟體的各方面議題，還可以再拆解嗎？只有「X軸」與「Ｙ軸」？「Z軸」會是誰呢？


### 維度思考：還可以再拆解嗎？

當系統開發出一個雛形的時候，相信有經驗的開發人員一定聽過客戶這樣說：「我的用戶要分成不同的角色，每個角色的功能特性會不一樣。比如，一般用戶的註冊功能只能得到普通帳戶，VIP用戶的註冊功能可以得到進階帳戶，應該很簡單對吧：）」

我們可以試著想像，在彼此不衝突的兩個維度中，如果「用戶註冊」的功能需求是第一個維度，那麼手機格式檢核的需求，也就是進一步提煉為「參數檢核」這個非功能性需求（正確性）成為第二個維度。「用戶的個人資料加密」跟參數格式好像沒什麼關係。仍然視為非功能性需求(機密性)成為第二個維度。那麼從「用戶要區分角色，對應用不同功能權限。」這個需求中可以發現，註冊是一種用戶的功能，用戶要區分角色，功能會因為角色不同的而有不同的功能特性。我們可以把「角色行為」當作第三個維度，同一個用戶在套用不同角色的時候，會有功能特性的區別。而這樣的特性可以用物件導向語言的多型（Polymorphism）機制來實現

- 第一個維度：功能性需求
- 第二個維度：非功能性需求（正確性、機密性）
- 第三個維度：角色行為（功能的不同行為特性）


以下透過一個簡單的範例程式，來說明如何運用Enum類別與多型機制來實現角色行為建模。

如果希望將 `UserRegistration` 的註冊行為和 `Role` 枚舉緊密結合，可以將 `UserRegistration` 的實作轉換為 `Role` 枚舉的一個屬性。這樣，當我們處理註冊邏輯時，根據 `Role` 來直接執行不同的註冊行為。


```java
// 定義用戶角色的 Enum 類別，將 UserRegistration 作為屬性
public enum Role {
    NORMAL(new RegularUserRegistration()), 
    VIP(new VIPUserRegistration()), 
    ADMIN(new AdminUserRegistration());

    // 每個角色擁有一個 UserRegistration 屬性
    private final UserRegistration registration;

    // 枚舉建構子
    Role(UserRegistration registration) {
        this.registration = registration;
    }

    // 提供一個方法來獲取對應的 UserRegistration
    public void register() {
        this.registration.register();
    }
}

// 定義用戶註冊的介面
public interface UserRegistration {
    void register();
}

// 一般用戶註冊的類別
public class RegularUserRegistration implements UserRegistration {
    @Override
    public void register() {
        System.out.println("註冊一般用戶：帳號權限為普通等級。");
    }
}

// VIP 用戶註冊的類別
public class VIPUserRegistration implements UserRegistration {
    @Override
    public void register() {
        System.out.println("註冊 VIP 用戶：帳號權限為進階等級，並享有額外功能。");
    }
}

// 管理員用戶註冊的類別
public class AdminUserRegistration implements UserRegistration {
    @Override
    public void register() {
        System.out.println("註冊管理員：帳號權限為最高等級，擁有系統管理功能。");
    }
}

// 用戶註冊處理類別
public class UserRegistrationService {
    public void processRegistration(Role role) {
        // 直接從 Role 枚舉中調用對應的註冊行為
        role.register();
    }
}

// 測試 Enum 與多型機制的主程式
public class Main {
    public static void main(String[] args) {
        UserRegistrationService registrationService = new UserRegistrationService();

        // 使用 Enum 與多型註冊一般用戶
        registrationService.processRegistration(Role.NORMAL);

        // 使用 Enum 與多型註冊 VIP 用戶
        registrationService.processRegistration(Role.VIP);

        // 使用 Enum 與多型註冊管理員用戶
        registrationService.processRegistration(Role.ADMIN);
    }
}
```

### 說明：
1. **`Role` 枚舉類**：每個枚舉常數 (`NORMAL`、`VIP`、`ADMIN`) 都關聯了一個 `UserRegistration` 的具體實作。這樣可以將註冊行為綁定到特定的角色中。
2. **`register()` 方法**：每個角色都可以直接調用 `register()` 方法，從而執行對應的註冊行為，這將邏輯集中在枚舉內部，而非在外部處理。
3. **`UserRegistrationService` 類別**：簡化了 `processRegistration` 方法，直接調用 `role.register()` 即可，減少了對 `switch` 語句的依賴。

這樣的設計更清晰且更具可擴展性，若有新的角色加入，只需在 `Role` 枚舉中添加相應的註冊邏輯即可。



說到這裡，我們總是可以隨著需求的複雜性，將架構從單純的功能性需求和非功能性需求，擴展到第三個維度，比如行為模型。假設我們面對的是一個多角色系統，不同用戶角色有著完全不同的操作行為，那我們就可以在架構中加入行為這個新維度。這樣，我們的架構不再僅僅是簡單的二維觀點，而是包含更多維度的行為交互，讓系統的邏輯更加清晰、更有「立體感」。


### 架構思維的自我修煉

在軟體開發的世界中，物件導向建模就像是在構建我們的「軟體宇宙坐標系」。每個類別、每個方法、每個行為都是這個坐標系中的一個點，透過這些點的精確定位，我們能夠對複雜的軟體需求進行有條不紊的拆解和處理。

這個過程其實有點像是我們在規劃一座城市。你可以想像，每一個功能需求就是城市中的一條街道，而非功能需求則是街道旁的基礎設施，比如供水、供電等等。而行為模型呢？那就是住在這座城市中的居民們，他們如何使用這個城市的每個角落。而我們這些開發者，扮演的就是城市的規劃者，既要確保街道順暢，也要讓居民住得舒適。整個過程就是在這浩瀚的軟體世界中，透過明確的架構規劃來建立秩序與指引。

在這個過程中，我們每個開發者都扮演著「小笛卡爾」的角色，因為我們都在利用這個虛擬的座標系統來引導整個開發過程。我們從模糊的需求出發，逐漸建立起精確的模型，最終呈現出一個符合需求的系統。這不僅讓我們自己不會迷失在開發過程中，也能讓我們的用戶明確知道自己得到了什麼。說到底，每一位軟體開發者都是「軟體世界的笛卡爾」，用架構這個「坐標系」來讓開發世界的每一步都精確無誤。

因此，下次當你在規劃一個軟體項目時，記得戴上你的「笛卡爾帽」，畫好你的X、Y軸，別忘了給它們加上第三個維度——用戶行為模型。相信我，這樣一來，你一定會避免迷路，並最終成功抵達終點。